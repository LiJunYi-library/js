function deleteKey(e,t,s){for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r))try{s&&(t[r]=""),delete t[r]}catch(e){}}function assignStyle(e,t){for(const s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]="",e[s]=t[s])}function convertToCamelCase(e){if(e.includes("-")){const t=e.split("-");return t[0]+t.slice(1).map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join("")}return e}function camelCaseToKebabCase(e){return e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}class RainbowEvent extends Event{constructor(e,t,s){if(super(e,t),this.detail=s,s instanceof Array)for(const e in s)try{void 0===this[e]&&(this[e]=s[e])}catch(e){console.warn(e)}}}function createCustomEvent(e,t,s={}){const r=new CustomEvent(e,{bubbles:!0,cancelable:!0,...s});for(const e in t)try{void 0===r[e]&&(r[e]=t[e])}catch(e){console.warn(e)}return r}function renderChildren(e={}){const t={parentNode:void 0,...e};let s,r=new Map;return{renderList:function(e=[],i){const n={beforeEach:()=>0,keyExtractor:(e,t)=>t,onCacheNode:()=>0,onCreateNode:()=>0,...i},o=new Map;s=void 0,n.beforeEach({cacheMap:r,pointer:s}),e.forEach(((e,i)=>{const l=n.keyExtractor(e,i);let a;r.has(l)?(a=r.get(l),n.onCacheNode(a,e,i,l),s&&(s.nextSibling===a||t.parentNode.insertBefore(a,s.nextSibling)),s=a,r.delete(l)):(a=n.onCreateNode(e,i,l),s?t.parentNode.insertBefore(a,void 0):t.parentNode.insertBefore(a,s?.nextSibling),s=a),o.set(l,a)})),r.forEach((e=>e.remove())),s=void 0,r=o}}}const events=new Map;new MutationObserver((e=>{events.forEach(((t,s)=>{t instanceof Function&&t.call(s,e)}))})).observe(document,{subtree:!0,attributes:!0,attributeOldValue:!0});const treeAttrsChangeIMP={simult:{init(){this.$changePropsRender&&events.set(this,(()=>this.$changePropsRender()))},disconnected(){events.delete(this)}},settle:{init(){}},async:{init(){}}};function resizeObserverIMP(e={}){let t;const s={isOnlyResizeWidth:!1,isOnlyResizeHeight:!1,resizeCallback:void 0,resizeOptions:{},...e};let r={};return{simult:{init(){const e=s.resizeCallback?s.resizeCallback.bind(this):this.$debouncedRender.bind(this);try{t=new ResizeObserver(((...t)=>{let i={width:this.offsetWidth,height:this.offsetHeight};s.isOnlyResizeWidth&&r.width!==i.width&&e(...t),s.isOnlyResizeHeight&&r.height!==i.height&&e(...t),s.isOnlyResizeWidth||s.isOnlyResizeHeight||e(...t),r=i})),t.observe(this,s.resizeOptions)}catch(e){console.warn(e)}},disconnected(){t.disconnect(this)}}}}function treeObserverIMP(e={}){let t,s;const r={childrenResizeOptions:{},onChildrenSizeChange(){},resizeOptions:{},onSizeChange(){},onWidthChange(){},onHeightChange(){},mutationOptions:{childList:!0},onChildChange(){},onAttributeChange(){},...e};let i={offset:{}};return{simult:{init(){try{s=new ResizeObserver(((e,...t)=>{let s={width:this.offsetWidth,height:this.offsetHeight};i.offset.width!==s.width&&r.onWidthChange.call(this,e,s),i.offset.height!==s.height&&r.onHeightChange.call(this,e,s),i.offset.width===s.width&&i.offset.height===s.height||r.onSizeChange.call(this,e,s),i.offset=s,!1===e.some((e=>e.target===this))&&r.onChildrenSizeChange.call(this,e)})),s?.observe?.(this,r.resizeOptions)}catch(e){console.warn(e)}t=new MutationObserver(((e,...t)=>{for(let t of e)if("childList"===t.type){const e=Array.from(t.addedNodes).filter((e=>e.style)),i=Array.from(t.removedNodes).filter((e=>e.style));e.forEach((e=>s.observe(e,r.childrenResizeOptions))),i.forEach((e=>s.unobserve(e))),r.onChildChange.call(this,t)}else"attributes"===t.type&&r.onAttributeChange.call(this,t)})),t.observe(this,r.mutationOptions)},disconnected(){t.disconnect(this),s.disconnect(this)}}}}function arrayAt(e,t){return e[t<0?e.length+t:t]}function arrayLoopMap(e,t){const s=[];for(let r=0;r<e;r++)s.push(t(r));return s}function animationDebounced(e){let t;return function(...s){cancelAnimationFrame(t),t=requestAnimationFrame((t=>{e(...s)}))}}Array.prototype.at||(Array.prototype.at=function(...e){return arrayAt(this,...e)});class RainbowElement extends HTMLElement{static $registerProps(e){const t=[],s={};for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t.push(r),e[r]?.default instanceof Function?s[r]=e[r].default(s):s[r]=e[r]?.default);return this.prototype.$types=e,this.prototype.$props=s,t}IMPS=[treeAttrsChangeIMP];$={isInitAttrs:!1,data:{},DATA:new Proxy({},{get:(e,t)=>this.$.data[camelCaseToKebabCase(t)]}),props:{...this.constructor.prototype.$props},resolveFunCss:{calc:(e,...t)=>e},resolveCss:(key,str="")=>{try{const isAttrFun=/r-attr\([^\)]*?\)/.test(str);isAttrFun&&(str=this.$.props[key]);let cssVal=str.replace(/\d+px|\d+vw|\d+vh/g,(e=>/\d+px/.test(e)?Number(e.replaceAll("px","")):/\d+vw/.test(e)?Number(e.replaceAll("vw",""))/100*window.innerWidth:/\d+vh/.test(e)?Number(e.replaceAll("vh",""))/100*window.innerHeight:e));const isFunstr=/([^\(]*?)\([^\)]*?\)/.test(cssVal);if(isFunstr)return eval(`this.$.resolveFunCss.${cssVal}`);let number=Number(cssVal);return isNaN(number)?cssVal:number}catch(e){return console.log(e),str}},cache:{data:{},style:{},class:new Map},setStyle:(e=()=>({}))=>{let t=e(this.$.data)||{},s=t;t instanceof Array&&(s=t.filter(Boolean).reduce(((e,t)=>(Object.assign(e,t),e)),{}));for(const e in s)Object.prototype.hasOwnProperty.call(s,e)&&(this.$.cache.style[e]!==s[e]&&(this.style[e]="",this.style[e]=s[e]),delete this.$.cache.style[e]);for(const e in this.$.cache.style)Object.prototype.hasOwnProperty.call(this.$.cache.style,e)&&(this.style[e]="");this.$.cache.style=s},setClass:(e=()=>[])=>{let t=e(this.$.data);void 0===t?.length&&(t=[t]),t=t.filter(Boolean);let s=new Map;t.forEach((e=>{s.set(e,e),this.$.cache.class.delete(e),this.classList.add(e)})),this.$.cache.class.forEach(((e,t)=>{this.classList.remove(e)})),this.$.cache.class=s},findParentByType:(e,t=this)=>{if(!t)return;const s=t.parentNode;if(!s)return;return s.constructor.name===e||s.$elementName===e?s:this.$.findParentByType(e,s)},getOffsetTop:(e,t=0)=>{let s=t+this.offsetTop;return this.offsetParent===e?s:this.$.getOffsetTop(this.offsetParent,s)}};constructor(...e){super(...e),this.IMPS.push(...this.$onRegisterIMPS?.()||[]),this.$debouncedRender=animationDebounced(((...e)=>this.$render(...e))),this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.init?.call?.(this)))}attributeChangedCallback(e,t,s){this.$.props[e]=s,!0===this.$.isInitAttrs&&this.$onAttributeChanged(e,t,s)}$onAttributeChanged(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.changeAttr?.call?.(this))),this.$changePropsRender()}connectedCallback(){this.$.isInitAttrs=!0,this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.connected?.call?.(this))),this.$changePropsRender()}adoptedCallback(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.adopted?.call?.(this)))}disconnectedCallback(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.disconnected?.call?.(this)))}$changePropsRender(e){let t=!1;const s={},r=window.getComputedStyle(this);for(const e in this.$.props)if(Object.prototype.hasOwnProperty.call(this.$.props,e)){const i=r.getPropertyValue("--"+e).trim();s[e]=this.$.resolveCss(e,i),this.$.cache.data[e]!==s[e]&&(t=!0)}return this.$.data=s,this.$.cache.data=s,(t||!0===e)&&this.$debouncedRender(s),s}$onRegisterIMPS(){return[]}$render(){}}class RGrid extends RainbowElement{static observedAttributes=this.$registerProps({"r-columns":{type:Number,default:1},"r-min-auto-width":Number,"r-gap":[Number,String],"r-row-gap":[Number,String],"r-column-gap":[Number,String],"r-grid-wrap":String,"r-grid-stretch":String});$onRegisterIMPS(){return[resizeObserverIMP({isOnlyResizeWidth:!0})]}$render(){const{rGap:e,rRowGap:t,rColumnGap:s}=this.$.DATA;this.$.setStyle((()=>[{"grid-template-columns":`repeat(${this.$$columns}, 1fr)`,"grid-gap":e+"px","row-gap":(t||e)+"px","column-gap":(s||e)+"px"}])),this.$$doLayout()}get $$columns(){let{rColumns:e,rMinAutoWidth:t}=this.$.DATA;return t?Math.floor(this.offsetWidth/t):e}$$doLayout(){const{rGridWrap:e,rGridStretch:t}=this.$.DATA;let s=Array.from(this.children),r=s.map((e=>1*e.getAttribute("grid-column")||1)),i=1,n=[],o=this.$$columns+1;r.forEach(((s,r)=>{let l=i+s;if("wrap"===e){if(l>o){"stretch"===t&&n[r-1]&&(n[r-1].end=o),i=1;let e=i+s;l=e>o?o:e}}else l>o&&(l=o);n.push({start:i,end:l,index:r}),i+=s,i>this.$$columns&&(i=1)})),s.forEach(((e,t)=>{e.classList.add("r-grid-item"),e.style["grid-column-start"]=n[t].start,e.style["grid-column-end"]=n[t].end}))}}customElements.define("r-grid",RGrid);class RFalls extends RainbowElement{static observedAttributes=this.$registerProps({"r-min-auto-width":Number,"r-columns":{type:Number,default:2},"r-gap":{type:Number,default:0},"r-row-gap":{type:Number,default:0},"r-column-gap":{type:Number,default:0}});$onRegisterIMPS(){return[treeObserverIMP({onWidthChange(){this.$debouncedRender(this.$?.data)},onChildrenSizeChange(){this.$debouncedRender(this.$?.data)}})]}$render(){let{rMinAutoWidth:e,rColumns:t,rGap:s,rRowGap:r,rColumnGap:i}=this.$.DATA;const n=(()=>e?Math.floor(this.offsetWidth/e):t)();let o=i||s,l=r||s,a=e=>`calc( ${100/n*e}% - ${(n-1)*o/n*e}px + ${e*o}px )`;const c=arrayLoopMap(n,(e=>({height:0,left:a(e),top:0,index:e})));let h=`calc( ${100/n}% - ${(n-1)*o/n}px )`;Array.from(this.children).forEach((e=>{e.classList.add("r-falls-item"),e.style.width=h;let t=getMinHeightItem(c);t.height&&(t.height=t.height+l),e.style.left=t.left,e.style.top=t.height+"px",t.height=t.height+e.offsetHeight})),this.style.height=getMaxHeightItem(c).height+"px"}}function getMinHeightItem(e){let t=e[0];return e.forEach((e=>{e.height<t.height&&(t=e)})),t}function getMaxHeightItem(e){let t=e[0];return e.forEach((e=>{e.height>t.height&&(t=e)})),t}customElements.define("r-falls",RFalls);class RScroll extends RainbowElement{$elementName="RScroll";$$scrollEl;$$prveScrollTop;get scrollTop(){return this.$$scrollEl.scrollTop}set scrollTop(e){this.$$scrollEl.scrollTop=e}scrollBy(...e){this.$$scrollEl.scrollBy(...e)}scrollTo(...e){this.$$scrollEl.scrollTo(...e)}constructor(...e){super(...e),this.attachShadow({mode:"open"}),this.$$scrollEl=document.createElement("div"),this.$$scrollEl.className="r-scroll-element",this.$$scrollEl.setAttribute("part","r-scroll-element  sdt");const t=document.createElement("div");t.className="r-scroll-content",t.setAttribute("part","r-scroll-content  sdt");const s=document.createElement("slot");s.setAttribute("name","top"),s.className="top";const r=document.createElement("slot");r.className="content";const i=document.createElement("slot");i.setAttribute("name","bottom"),i.className="bottom",t.appendChild(r),this.$$scrollEl.appendChild(s),this.$$scrollEl.appendChild(t),this.$$scrollEl.appendChild(i),this.shadowRoot.appendChild(this.$$scrollEl),this.$$scrollEl.addEventListener("scroll",this.$$onScroll.bind(this))}$$onScroll(e){const t=this.$$scrollEl;e.scrollTop=t.scrollTop,e.moveY=this.$$prveScrollTop-t.scrollTop,e.moveY<0&&this.dispatchEvent(createCustomEvent("scrollUp",e)),this.onscroll&&this.onscroll(e),this.dispatchEvent(createCustomEvent("scroll",e)),e.moveY>0&&this.dispatchEvent(createCustomEvent("scrollDown",e)),this.$$prveScrollTop=t.scrollTop}connectedCallback(...e){super.connectedCallback(...e),this.$$prveScrollTop=this.$$scrollEl.scrollTop}disconnectedCallback(...e){super.connectedCallback(...e),this.$$scrollEl.removeEventListener("scroll",this.$$onScroll.bind(this))}}customElements.define("r-scroll",RScroll);class RScrollMemoryBubble extends RainbowElement{static observedAttributes=this.$registerProps({"r-orientation":{type:String,default:"right"},"r-init-visibility":{type:String,default:"visible"},"r-visible-distance":{type:String,default:"100px"},"r-visible-reversal":String});$$visible=!0;$$cacheMoveY=0;$$scrollParent;connectedCallback(...e){super.connectedCallback(...e),this.$$visible="visible"===this.$.DATA.rInitVisibility,this.$$scrollParent=this.$.findParentByType("RScroll"),this.$$scrollParent.addEventListener("scrollUp",this.$$setVisibleFalse.bind(this)),this.$$scrollParent.addEventListener("scrollDown",this.$$setVisibleTrue.bind(this))}disconnectedCallback(...e){super.connectedCallback(...e),this.$$scrollParent.removeEventListener("scrollUp",this.$$setVisibleFalse.bind(this)),this.$$scrollParent.removeEventListener("scrollDown",this.$$setVisibleTrue.bind(this))}$$setClass(){const{rOrientation:e}=this.$.DATA;this.$.setClass((()=>["r-scroll-memory-bubble-"+e,this.$$visible?"r-scroll-memory-bubble-visible":"r-scroll-memory-bubble-hide",this.$$visible?`r-scroll-memory-bubble-visible-${e}`:`r-scroll-memory-bubble-hide-${e}`]))}$$setVisibleTrue(e){if(!0===this.$$visible)return this.$$cacheMoveY=0;this.$$cacheMoveY=this.$$cacheMoveY+Math.abs(e.moveY),this.$$cacheMoveY>=this.$.DATA.rVisibleDistance&&(this.$$cacheMoveY=0,this.$$visible=!0,this.$$setClass())}$$setVisibleFalse(e){if(!1===this.$$visible)return this.$$cacheMoveY=0;this.$$cacheMoveY=this.$$cacheMoveY+Math.abs(e.moveY),this.$$cacheMoveY>=this.$.DATA.rVisibleDistance&&(this.$$cacheMoveY=0,this.$$visible=!1,this.$$setClass())}$render(){this.$$setClass()}}customElements.define("r-scroll-memory-bable",RScrollMemoryBubble);class RRollingTextNum extends RainbowElement{static observedAttributes=this.$registerProps({"r-initial-animation":String,"r-transition":String});$$container=document.createElement("span");$$measure=document.createElement("span");$$rotes=arrayLoopMap(10,(()=>document.createElement("span")));$$num=10;$$value=0;$$isMonted=!1;get $$deg(){return 360/this.$$num}get value(){return this.$$value}set value(e){this.$$value=e,!1!==this.$$isMonted&&this.$$rotateX(!0)}setValue(e,t=!0){this.$$value=e,!1!==this.$$isMonted&&this.$$rotateX(t)}constructor(...e){super(...e),this.attachShadow({mode:"open"}),this.$$container.className="r-rolling-num-container r-rolling-num-container-ani",this.$$container.setAttribute("part","r-rolling-num-container r-rolling-num-container-ani "),this.$$measure.className="r-rolling-num-measure",this.$$measure.setAttribute("part","r-rolling-num-measure"),this.$$measure.innerText="9",this.$$container.appendChild(this.$$measure),this.shadowRoot.appendChild(this.$$container)}$$renderNums(){const e=this.$$deg,t=(Math.sin(Math.PI/180*e)+.9)*(this.$$measure.offsetHeight||1);this.$$rotes.forEach(((s,r)=>{s.style.transform=`rotateX(${e*r}deg)  translateZ(${t}px)`,s.setAttribute("part","r-rolling-num-rotate"),s.className="r-rolling-num-rotate",s.innerText=r,this.$$container.appendChild(s)}))}async $$rotateX(e){const{rTransition:t,rInitialAnimation:s}=this.$.DATA,r=-this.$$value/this.$$num*360;let i=-Math.round((r-180)%360/36);this.$$rotes.forEach(((e,t)=>{let s="r-rolling-num-rotate";i===t&&(s="r-rolling-num-rotate r-rolling-num-rotate-unact"),(i-1<0?9:i-1)===t&&(s="r-rolling-num-rotate r-rolling-num-rotate-unprve"),(i+1>9?0:i+1)===t&&(s="r-rolling-num-rotate r-rolling-num-rotate-unnext"),e.setAttribute("part",s),e.className=s})),e&&(this.$$container.style.transition="",this.$$container.style.transition=t),this.$$container.style.transform="",this.$$container.style.transform=`rotateX(${r}deg)`}$render(){}connectedCallback(...e){super.connectedCallback(...e);const{rTransition:t,rInitialAnimation:s}=this.$.DATA;this.$$renderNums(),this.$$rotateX("true"===s),this.$$isMonted=!0}disconnectedCallback(...e){super.connectedCallback(...e)}}customElements.define("r-rolling-text-num",RRollingTextNum);class RRollingText extends RainbowElement{static observedAttributes=this.$registerProps({"r-value":String,"r-math-type":String});$$renderNumNodes=renderChildren({parentNode:this});$render(){let{rValue:e,rMathType:t}=this.$.DATA,s=arrayLoopMap(String(e).length,(s=>{const r=Number([1,...arrayLoopMap(s,(()=>0))].join(""));return"floor"===t?Math.floor(e/r):e/r}));this.$$renderNumNodes.renderList(s,{keyExtractor:(e,t)=>t,onCreateNode:(e,t,s)=>{let r=document.createElement("r-rolling-text-num");return r.setAttribute("key",s),r.value=e,r},onCacheNode:(e,t,s,r)=>(e.value=t,e.setAttribute("key",r),e)})}}customElements.define("r-rolling-text",RRollingText);export{RFalls,RGrid,RRollingText,RRollingTextNum,RScroll,RScrollMemoryBubble,RainbowElement,RainbowEvent,assignStyle,camelCaseToKebabCase,convertToCamelCase,createCustomEvent,deleteKey,renderChildren};
//# sourceMappingURL=index.js.map
