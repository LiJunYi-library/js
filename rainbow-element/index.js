function deleteKey(e,t,s){for(const i in e)if(Object.prototype.hasOwnProperty.call(e,i))try{s&&(t[i]=""),delete t[i]}catch(e){}}function assignStyle(e,t){for(const s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]="",e[s]=t[s])}function convertToCamelCase(e){if(e.includes("-")){const t=e.split("-");return t[0]+t.slice(1).map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join("")}return e}function camelCaseToKebabCase(e){return e.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}class RainbowEvent extends Event{constructor(e,t,s){if(super(e,t),this.detail=s,s instanceof Array)for(const e in s)try{void 0===this[e]&&(this[e]=s[e])}catch(e){console.warn(e)}}}function createCustomEvent(e,t,s={}){const i=new CustomEvent(e,{bubbles:!0,cancelable:!0,...s});for(const e in t)try{void 0===i[e]&&(i[e]=t[e])}catch(e){console.warn(e)}return i}function renderChildren(e={}){const t={parentNode:void 0,...e};let s,i=new Map;return{renderList:function(e=[],r){const n={beforeEach:()=>0,keyExtractor:(e,t)=>t,onCacheNode:()=>0,onCreateNode:()=>0,...r},o=new Map;s=void 0,n.beforeEach({cacheMap:i,pointer:s}),e.forEach(((e,r)=>{const l=n.keyExtractor(e,r);let a;i.has(l)?(a=i.get(l),n.onCacheNode(a,e,r,l),s&&(s.nextSibling===a||t.parentNode.insertBefore(a,s.nextSibling)),s=a,i.delete(l)):(a=n.onCreateNode(e,r,l),s?t.parentNode.insertBefore(a,void 0):t.parentNode.insertBefore(a,s?.nextSibling),s=a),o.set(l,a)})),i.forEach((e=>e.remove())),s=void 0,i=o}}}const events=new Map;new MutationObserver((e=>{events.forEach(((t,s)=>{t instanceof Function&&t.call(s,e)}))})).observe(document,{subtree:!0,attributes:!0,attributeOldValue:!0});const treeAttrsChangeIMP={simult:{init(){this.$changePropsRender&&events.set(this,(()=>this.$changePropsRender()))},disconnected(){events.delete(this)}},settle:{init(){}},async:{init(){}}};function resizeObserverIMP(e={}){let t;const s={isOnlyResizeWidth:!1,isOnlyResizeHeight:!1,resizeCallback:void 0,resizeOptions:{},...e};let i={};return{simult:{init(){const e=s.resizeCallback?s.resizeCallback.bind(this):this.$debouncedRender.bind(this);try{t=new ResizeObserver(((...t)=>{let r={width:this.offsetWidth,height:this.offsetHeight};s.isOnlyResizeWidth&&i.width!==r.width&&e(...t),s.isOnlyResizeHeight&&i.height!==r.height&&e(...t),s.isOnlyResizeWidth||s.isOnlyResizeHeight||e(...t),i=r})),t.observe(this,s.resizeOptions)}catch(e){console.warn(e)}},disconnected(){t.disconnect(this)}}}}function treeObserverIMP(e={}){let t,s;const i={childrenResizeOptions:{},onChildrenSizeChange(){},resizeOptions:{},onSizeChange(){},onWidthChange(){},onHeightChange(){},mutationOptions:{childList:!0},onChildChange(){},onAttributeChange(){},...e};let r={offset:{}};return{simult:{init(){try{s=new ResizeObserver(((e,...t)=>{let s={width:this.offsetWidth,height:this.offsetHeight};r.offset.width!==s.width&&i.onWidthChange.call(this,e,s),r.offset.height!==s.height&&i.onHeightChange.call(this,e,s),r.offset.width===s.width&&r.offset.height===s.height||i.onSizeChange.call(this,e,s),r.offset=s,!1===e.some((e=>e.target===this))&&i.onChildrenSizeChange.call(this,e)})),s?.observe?.(this,i.resizeOptions)}catch(e){console.warn(e)}t=new MutationObserver(((e,...t)=>{for(let t of e)if("childList"===t.type){const e=Array.from(t.addedNodes).filter((e=>e.style)),r=Array.from(t.removedNodes).filter((e=>e.style));e.forEach((e=>s.observe(e,i.childrenResizeOptions))),r.forEach((e=>s.unobserve(e))),i.onChildChange.call(this,t)}else"attributes"===t.type&&i.onAttributeChange.call(this,t)})),t.observe(this,i.mutationOptions)},disconnected(){t.disconnect(this),s.disconnect(this)}}}}function arrayAt(e,t){return e[t<0?e.length+t:t]}function arrayLoopMap(e,t){const s=[];for(let i=0;i<e;i++)s.push(t(i));return s}function animationDebounced(e){let t;return function(...s){cancelAnimationFrame(t),t=requestAnimationFrame((t=>{e(...s)}))}}Array.prototype.at||(Array.prototype.at=function(...e){return arrayAt(this,...e)});class RainbowElement extends HTMLElement{static $registerProps(e){const t=[],s={};for(const i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t.push(i),e[i]?.default instanceof Function?s[i]=e[i].default(s):s[i]=e[i]?.default);return this.prototype.$types=e,this.prototype.$props=s,t}static registerIMPS(e=[]){this.prototype.IMPS=[treeAttrsChangeIMP,...e]}static IMPS=this.registerIMPS();$={isInitAttrs:!1,data:{},DATA:new Proxy({},{get:(e,t)=>this.$.data[camelCaseToKebabCase(t)]}),attrs:{},resolveFunCss:{calc:(e,...t)=>e},resolveCss:(key,str="")=>{try{const isAttrFun=/r-attr\([^\)]*?\)/.test(str);isAttrFun&&(str=this.$props[key]);let cssVal=str.replace(/\d+px|\d+vw|\d+vh/g,(e=>/\d+px/.test(e)?Number(e.replaceAll("px","")):/\d+vw/.test(e)?Number(e.replaceAll("vw",""))/100*window.innerWidth:/\d+vh/.test(e)?Number(e.replaceAll("vh",""))/100*window.innerHeight:e));const isFunstr=/([^\(]*?)\([^\)]*?\)/.test(cssVal);if(isFunstr)return eval(`this.$.resolveFunCss.${cssVal}`);let number=Number(cssVal);return isNaN(number)?cssVal:number}catch(e){return console.log(e),str}},cache:{data:{},style:{},class:new Map},setStyle:(e=()=>({}))=>{let t=e(this.$.data)||{},s=t;t instanceof Array&&(s=t.filter(Boolean).reduce(((e,t)=>(Object.assign(e,t),e)),{}));for(const e in s)Object.prototype.hasOwnProperty.call(s,e)&&(this.$.cache.style[e]!==s[e]&&(this.style[e]="",this.style[e]=s[e]),delete this.$.cache.style[e]);for(const e in this.$.cache.style)Object.prototype.hasOwnProperty.call(this.$.cache.style,e)&&(this.style[e]="");this.$.cache.style=s},setClass:(e=()=>[])=>{let t=e(this.$.data);void 0===t?.length&&(t=[t]),t=t.filter(Boolean);let s=new Map;t.forEach((e=>{s.set(e,e),this.$.cache.class.delete(e),this.classList.add(e)})),this.$.cache.class.forEach(((e,t)=>{this.classList.remove(e)})),this.$.cache.class=s},findParentByType:(e,t=this)=>{if(!t)return;const s=t.parentNode;if(!s)return;return s.constructor.name===e||s.$elementName===e?s:this.$.findParentByType(e,s)},getOffsetTop:(e,t=0)=>{let s=t+this.offsetTop;return this.offsetParent===e?s:this.$.getOffsetTop(this.offsetParent,s)}};constructor(...e){super(...e),this.$debouncedRender=animationDebounced(((...e)=>this.$render(...e))),this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.init?.call?.(this)))}attributeChangedCallback(e,t,s){this.$props[e]=s,!0===this.$.isInitAttrs&&this.$onAttributeChanged(e,t,s)}$onAttributeChanged(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.changeAttr?.call?.(this))),this.$changePropsRender()}connectedCallback(){this.$.isInitAttrs=!0,this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.connected?.call?.(this))),this.$changePropsRender()}adoptedCallback(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.adopted?.call?.(this)))}disconnectedCallback(){this.IMPS.map((e=>e?.simult))?.forEach((e=>e?.disconnected?.call?.(this)))}$changePropsRender(e){let t=!1;const s={},i=window.getComputedStyle(this);for(const e in this.$props)if(Object.prototype.hasOwnProperty.call(this.$props,e)){const r=i.getPropertyValue("--"+e).trim();s[e]=this.$.resolveCss(e,r),this.$.cache.data[e]!==s[e]&&(t=!0)}return this.$.data=s,this.$.cache.data=s,(t||!0===e)&&this.$debouncedRender(s),s}$render(){}}class RGrid extends RainbowElement{static observedAttributes=this.$registerProps({"r-columns":{type:Number,default:1},"r-min-auto-width":Number,"r-gap":[Number,String],"r-row-gap":[Number,String],"r-column-gap":[Number,String],"r-grid-wrap":String,"r-grid-stretch":String});static IMPS=this.registerIMPS([resizeObserverIMP({isOnlyResizeWidth:!0})]);get $$columns(){let{rColumns:e,rMinAutoWidth:t}=this.$.DATA;return t?Math.floor(this.offsetWidth/t):e}$$doLayout(){const{rGridWrap:e,rGridStretch:t}=this.$.DATA;let s=Array.from(this.children),i=s.map((e=>1*e.getAttribute("grid-column")||1)),r=1,n=[],o=this.$$columns+1;i.forEach(((s,i)=>{let l=r+s;if("wrap"===e){if(l>o){"stretch"===t&&n[i-1]&&(n[i-1].end=o),r=1;let e=r+s;l=e>o?o:e}}else l>o&&(l=o);n.push({start:r,end:l,index:i}),r+=s,r>this.$$columns&&(r=1)})),s.forEach(((e,t)=>{e.classList.add("r-grid-item"),e.style["grid-column-start"]=n[t].start,e.style["grid-column-end"]=n[t].end}))}$render(){console.log(this.$.data);const{rGap:e,rRowGap:t,rColumnGap:s}=this.$.DATA;this.$.setStyle((()=>[{"grid-template-columns":`repeat(${this.$$columns}, 1fr)`,"grid-gap":e+"px","row-gap":(t||e)+"px","column-gap":(s||e)+"px"}])),this.$$doLayout()}}customElements.define("r-grid",RGrid);class RAbsolute extends RainbowElement{static observedAttributes=this.$registerProps({"r-position":[Boolean,String]})}customElements.define("r-absolute",RAbsolute);class RFalls extends RainbowElement{static observedAttributes=this.$registerProps({"r-min-auto-width":Number,"r-columns":{type:Number,default:2},"r-gap":{type:Number,default:0},"r-row-gap":{type:Number,default:0},"r-column-gap":{type:Number,default:0}});static IMPS=this.registerIMPS([treeObserverIMP({onWidthChange(){this.$debouncedRender(this.$?.data)},onChildrenSizeChange(){this.$debouncedRender(this.$?.data)}})]);$render(){let{rMinAutoWidth:e,rColumns:t,rGap:s,rRowGap:i,rColumnGap:r}=this.$.DATA;const n=(()=>e?Math.floor(this.offsetWidth/e):t)();let o=r||s,l=i||s,a=e=>`calc( ${100/n*e}% - ${(n-1)*o/n*e}px + ${e*o}px )`;const c=arrayLoopMap(n,(e=>({height:0,left:a(e),top:0,index:e})));let h=`calc( ${100/n}% - ${(n-1)*o/n}px )`;Array.from(this.children).forEach((e=>{e.classList.add("r-falls-item"),e.style.width=h;let t=getMinHeightItem(c);t.height&&(t.height=t.height+l),e.style.left=t.left,e.style.top=t.height+"px",t.height=t.height+e.offsetHeight})),this.style.height=getMaxHeightItem(c).height+"px"}}function getMinHeightItem(e){let t=e[0];return e.forEach((e=>{e.height<t.height&&(t=e)})),t}function getMaxHeightItem(e){let t=e[0];return e.forEach((e=>{e.height>t.height&&(t=e)})),t}customElements.define("r-falls",RFalls);class RScroll extends RainbowElement{$elementName="RScroll";$$scrollEl;$$prveScrollTop;get scrollTop(){return this.$$scrollEl.scrollTop}set scrollTop(e){this.$$scrollEl.scrollTop=e}scrollBy(...e){this.$$scrollEl.scrollBy(...e)}scrollTo(...e){this.$$scrollEl.scrollTo(...e)}constructor(...e){super(...e),this.attachShadow({mode:"open"}),this.$$scrollEl=document.createElement("div"),this.$$scrollEl.className="r-scroll-element",this.$$scrollEl.setAttribute("part","r-scroll-element  sdt");const t=document.createElement("div");t.className="r-scroll-content",t.setAttribute("part","r-scroll-content  sdt");const s=document.createElement("slot");s.setAttribute("name","top"),s.className="top";const i=document.createElement("slot");i.className="content";const r=document.createElement("slot");r.setAttribute("name","bottom"),r.className="bottom",t.appendChild(i),this.$$scrollEl.appendChild(s),this.$$scrollEl.appendChild(t),this.$$scrollEl.appendChild(r),this.shadowRoot.appendChild(this.$$scrollEl),this.$$scrollEl.addEventListener("scroll",this.$$onScroll.bind(this))}$$onScroll(e){const t=this.$$scrollEl;e.scrollTop=t.scrollTop,e.moveY=this.$$prveScrollTop-t.scrollTop,e.moveY<0&&this.dispatchEvent(createCustomEvent("scrollUp",e)),this.onscroll&&this.onscroll(e),this.dispatchEvent(createCustomEvent("scroll",e)),e.moveY>0&&this.dispatchEvent(createCustomEvent("scrollDown",e)),this.$$prveScrollTop=t.scrollTop}connectedCallback(...e){super.connectedCallback(...e),this.$$prveScrollTop=this.$$scrollEl.scrollTop}disconnectedCallback(...e){super.connectedCallback(...e),this.$$scrollEl.removeEventListener("scroll",this.$$onScroll.bind(this))}}customElements.define("r-scroll",RScroll);class RScrollMemoryBubble extends RainbowElement{static observedAttributes=this.$registerProps({"r-orientation":{type:String,default:"right"},"r-init-visibility":{type:String,default:"visible"},"r-visible-distance":{type:String,default:"100px"},"r-visible-reversal":String});$$visible=!0;$$cacheMoveY=0;$$scrollParent;connectedCallback(...e){super.connectedCallback(...e),this.$$visible="visible"===this.$.DATA.rInitVisibility,this.$$scrollParent=this.$.findParentByType("RScroll"),this.$$scrollParent.addEventListener("scrollUp",this.$$setVisibleFalse.bind(this)),this.$$scrollParent.addEventListener("scrollDown",this.$$setVisibleTrue.bind(this))}disconnectedCallback(...e){super.connectedCallback(...e),this.$$scrollParent.removeEventListener("scrollUp",this.$$setVisibleFalse.bind(this)),this.$$scrollParent.removeEventListener("scrollDown",this.$$setVisibleTrue.bind(this))}$$setClass(){const{rOrientation:e}=this.$.DATA;this.$.setClass((()=>["r-scroll-memory-bubble-"+e,this.$$visible?"r-scroll-memory-bubble-visible":"r-scroll-memory-bubble-hide",this.$$visible?`r-scroll-memory-bubble-visible-${e}`:`r-scroll-memory-bubble-hide-${e}`]))}$$setVisibleTrue(e){if(!0===this.$$visible)return this.$$cacheMoveY=0;this.$$cacheMoveY=this.$$cacheMoveY+Math.abs(e.moveY),this.$$cacheMoveY>=this.$.DATA.rVisibleDistance&&(this.$$cacheMoveY=0,this.$$visible=!0,this.$$setClass())}$$setVisibleFalse(e){if(!1===this.$$visible)return this.$$cacheMoveY=0;this.$$cacheMoveY=this.$$cacheMoveY+Math.abs(e.moveY),this.$$cacheMoveY>=this.$.DATA.rVisibleDistance&&(this.$$cacheMoveY=0,this.$$visible=!1,this.$$setClass())}$render(){this.$$setClass()}}customElements.define("r-scroll-memory-bable",RScrollMemoryBubble);class RRollingTextNum extends RainbowElement{static observedAttributes=this.$registerProps({"r-initial-animation":String,"r-transition":String});$$container=document.createElement("span");$$measure=document.createElement("span");$$rotes=arrayLoopMap(10,(()=>document.createElement("span")));$$num=10;$$value=0;$$isMonted=!1;get value(){return this.$$value}set value(e){this.$$value=e,!1!==this.$$isMonted&&this.$$rotateX(!0)}setValue(e,t=!0){this.$$value=e,!1!==this.$$isMonted&&this.$$rotateX(t)}constructor(...e){super(...e),this.attachShadow({mode:"open"}),this.$$container.className="r-rolling-num-container r-rolling-num-container-ani",this.$$container.setAttribute("part","r-rolling-num-container r-rolling-num-container-ani "),this.$$measure.className="r-rolling-num-measure",this.$$measure.setAttribute("part","r-rolling-num-measure"),this.$$measure.innerText="9",this.$$container.appendChild(this.$$measure),this.shadowRoot.appendChild(this.$$container)}$$renderNums(){const e=360/this.$$num,t=(Math.sin(Math.PI/180*e)+.9)*(this.$$measure.offsetHeight||1);this.$$rotes.forEach(((s,i)=>{s.style.transform=`rotateX(${e*i}deg)  translateZ(${t}px)`,s.setAttribute("part","r-rolling-num-rotate"),s.className="r-rolling-num-rotate",s.innerText=i,this.$$container.appendChild(s)}))}async $$rotateX(e){const{rTransition:t,rInitialAnimation:s}=this.$.DATA,i=-this.$$value/this.$$num*360;e&&(this.$$container.style.transition="",this.$$container.style.transition=t),this.$$container.style.transform="",this.$$container.style.transform=`rotateX(${i}deg)`}$render(){}connectedCallback(...e){super.connectedCallback(...e);const{rTransition:t,rInitialAnimation:s}=this.$.DATA;this.$$renderNums(),this.$$rotateX("true"===s),this.$$isMonted=!0}disconnectedCallback(...e){super.connectedCallback(...e)}}customElements.define("r-rolling-text-num",RRollingTextNum);class RRollingText extends RainbowElement{static observedAttributes=this.$registerProps({"r-value":String,"r-math-type":String});$$renderNumNodes=renderChildren({parentNode:this});$render(){let{rValue:e,rMathType:t}=this.$.DATA,s=arrayLoopMap(String(e).length,(s=>{const i=Number([1,...arrayLoopMap(s,(()=>0))].join(""));return"floor"===t?Math.floor(e/i):e/i}));this.$$renderNumNodes.renderList(s,{keyExtractor:(e,t)=>t,onCreateNode:(e,t,s)=>{let i=document.createElement("r-rolling-text-num");return i.setAttribute("key",s),i.value=e,i},onCacheNode:(e,t,s,i)=>(e.value=t,e.setAttribute("key",i),e)})}}customElements.define("r-rolling-text",RRollingText);export{RAbsolute,RFalls,RGrid,RRollingText,RRollingTextNum,RScroll,RScrollMemoryBubble,RainbowElement,RainbowEvent,assignStyle,camelCaseToKebabCase,convertToCamelCase,createCustomEvent,deleteKey,renderChildren};
//# sourceMappingURL=index.js.map
