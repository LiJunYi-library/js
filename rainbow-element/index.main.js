var rainbowElement = function (t) { "use strict"; function e(t, e, s) { for (const i in t) if (Object.prototype.hasOwnProperty.call(t, i)) try { s && (e[i] = ""), delete e[i] } catch (t) { } } class s extends HTMLElement { static $initProps(t) { const e = [], s = {}; for (const i in t) Object.prototype.hasOwnProperty.call(t, i) && (e.push(i), t[i]?.default instanceof Function ? s[i] = t[i].default(s) : s[i] = t[i]?.default); return this.prototype.$props = t, this.prototype.$attrs = s, e } $ASTProps = {}; $isASTinit = !1; $childrenResizeObserver; $resizeObserver; $mutationObserver; $mutationObserverInit = { childList: !0 }; $cache = { offset: {}, class: new Map, style: {} }; $renderEvents = []; constructor() { super(), console.log('constructor',this),  this.$initResizeObserver(), this.$initMutationObserver(), this.$initChildrenResizeObserver() } $setStyle(t = () => ({})) { let s = t(this.$attrs) || {}, i = s; s instanceof Array && (i = s.filter(Boolean).reduce(((t, e) => (Object.assign(t, e), t)), {})), e(i, this.$cache.style), e(this.$cache.style, this.style, !0), function (t, e) { for (const s in e) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s], t[s] !== e[s] && (t[s] = "", console.warn(` style ${s} set ${e[s]} 失败 已重置为 ''`))) }(this.style, i), this.$cache.style = i } $setClass(t = () => []) { let e = t(this.$attrs); void 0 === e?.length && (e = [e]), e = e.filter(Boolean); let s = new Map; e.forEach((t => { s.set(t, t), this.$cache.class.delete(t), this.classList.add(t) })), this.$cache.class.forEach(((t, e) => { this.classList.remove(t) })), this.$cache.class = s } $createCustomEvent(t, e, s = {}) { const i = new CustomEvent(t, { bubbles: !0, cancelable: !0, ...s }); for (const t in e) try { void 0 === i[t] && (i[t] = e[t]) } catch (t) { console.warn(t) } return i } $getParentByType(t, e = this) { if (!e) return; const s = e.parentNode; if (!s) return; return s.constructor.name === t || s.$elementName === t ? s : this.$getParentByType(t, s) } $dispatchOn(t, ...e) { this?.[t]?.(...e), this.$renderEvents.includes(t) && this.$onRender(t, ...e) } $initMutationObserver() { try { this.$mutationObserver = new MutationObserver(this.$mutationObserverCB.bind(this)), this.$mutationObserver.observe(this, this.$mutationObserverInit) } catch (t) { console.warn(t) } } $mutationObserverCB(t, ...e) { this.$dispatchOn("$onMutation", t, ...e); for (let e of t) if ("childList" === e.type) { const t = Array.from(e.addedNodes).filter((t => t.style)), s = Array.from(e.removedNodes).filter((t => t.style)); t.forEach((t => this.$childrenResizeObserver.observe(t))), s.forEach((t => this.$childrenResizeObserver.unobserve(t))), this.$dispatchOn("$onChildChange", e) } else "attributes" === e.type && this.$dispatchOn("$onAttributeChange", e) } $onRender() { } $onMutation() { } $onChildChange() { } $onAttributeChange() { } $initChildrenResizeObserver() { try { this.$childrenResizeObserver = new ResizeObserver(this.$childrenResizeObserverCB.bind(this)) } catch (t) { console.warn(t) } } $childrenResizeObserverCB(...t) { this.$dispatchOn("$onChildrenResize", ...t) } $initResizeObserver() { try { this.$resizeObserver = new ResizeObserver(this.$resizeObserverCB.bind(this)), this.$resizeObserver.observe(this) } catch (t) { console.warn(t) } } $resizeObserverCB(...t) { this.$dispatchOn("$onResizeObserver", ...t); const e = this.$cache.offset, s = this?.getBoundingClientRect?.(); e.width === s.width && e.height === s.height || this.$dispatchOn("$onResize", s, ...t), e.width !== s.width && this.$dispatchOn("$onWidthChange", s, ...t), e.height !== s.height && this.$dispatchOn("$onHeightChange", s, ...t), this.$cache.offset = s } $onResize() { } $onWidthChange() { } $onHeightChange() { } $setAttrsProp(t, e) { const s = this.$props[t]; if (!s) return this.$attrs[t] = e; let i = s.type || s; if (i instanceof Array) { let t = i.map((t => t.name)); i = t.includes("String") ? String : i[0] } let r = "true" === e || "false" !== e && ("null" === e ? null : "undefined" !== e ? i(e) : void 0); this.$attrs[t] = r } $onAttrsChange() { } attributeChangedCallback(t, e, s) { !1 === this.$isASTinit && (this.$ASTProps[t] = s), this.$attrs[t] = s, this.$setAttrsProp(t, s), !0 === this.$isASTinit && this.$dispatchOn("$onAttrsChange", this.$attrs, t, e, s) } $onConnected() { } connectedCallback() { console.log('connectedCallback',this), this.$isASTinit = !0, Array.from(this.children).forEach((t => this.$childrenResizeObserver.observe(t))), this.$dispatchOn("$onConnected") } $onAdopted() { } adoptedCallback() { this.$dispatchOn("$onAdopted") } $onDisconnected() { } disconnectedCallback() { this.$resizeObserver?.disconnect?.(), this.$childrenResizeObserver?.disconnect?.(), this.$mutationObserver?.disconnect?.(), this.$dispatchOn("$onDisconnected") } } class i extends s { static observedAttributes = this.$initProps({ columns: { type: Number, default: 1 }, gap: [Number, String], "row-gap": [Number, String], "column-gap": [Number, String], inline: Boolean, "min-auto-width": Number, wrap: Boolean, stretch: Boolean, onred: Function }); $renderEvents = ["$onMutation", "$onWidthChange", "$onAttrsChange"]; get $columns() { return this.$attrs["min-auto-width"] ? Math.floor(this.offsetWidth / this.$attrs["min-auto-width"]) : this.$attrs.columns } $doLayout() { let t = this.$attrs, e = Array.from(this.children), s = e.map((t => 1 * t.getAttribute("grid-column") || 1)), i = 1, r = [], n = this.$columns + 1; s.forEach(((e, s) => { let o = i + e; if (t.wrap) { if (o > n) { t.stretch && r[s - 1] && (r[s - 1].end = n), i = 1; let l = i + e; o = l > n ? n : l } } else o > n && (o = n); r.push({ start: i, end: o, index: s }), i += e, i > this.$columns && (i = 1) })), e.forEach(((t, e) => { t.classList.add("r-grid-item"), t.style["grid-column-start"] = r[e].start, t.style["grid-column-end"] = r[e].end })) } $onRender() { this.$setClass((() => ["r-grid"])), this.$setStyle((t => ({ display: t.inline ? "inline-grid" : "grid", "grid-template-columns": ` repeat(${this.$columns}, 1fr)`, "grid-gap": t.gap + "px", "row-gap": (t["row-gap"] || t.gap) + "px", "column-gap": (t["column-gap"] || t.gap) + "px" }))), this.$doLayout() } } customElements.define("r-grid", i); class r extends s { static observedAttributes = this.$initProps({ position: [Boolean, String], left: [Number, String], right: [Number, String], bottom: [Number, String], top: [Number, String] }); $CacheClass; $renderEvents = ["$onConnected", "$onAttrsChange"]; $onRender() { this.$setClass((t => ["r-absolute", t.position && "r-absolute-" + t.position])) } } customElements.define("r-absolute", r), Array.prototype.at || (Array.prototype.at = function (...t) { return function (t, e) { let s = e < 0 ? t.length + e : e; return t[s] }(this, ...t) }); class n extends s { static observedAttributes = this.$initProps({ "min-auto-width": Number, columns: { type: Number, default: 2 }, gap: { type: Number, default: 0 }, "row-gap": { type: Number, default: 0 }, "column-gap": { type: Number, default: 0 } }); constructor(...t) { super(...t) } get $col() { return this.$attrs["min-auto-width"] ? Math.floor(this.offsetWidth / this.$attrs["min-auto-width"]) : this.$attrs.columns } get $coGap() { return this.$attrs["column-gap"] || this.$attrs.gap } get $roGap() { return this.$attrs["row-gap"] || this.$attrs.gap } get $itemWidth() { return `calc( ${100 / this.$col}% - ${(this.$col - 1) * this.$coGap / this.$col}px )` } $getLeft(t) { return `calc( ${100 / this.$col * t}% - ${(this.$col - 1) * this.$coGap / this.$col * t}px + ${t * this.$coGap}px )` } $createList() { const t = function (t, e) { const s = []; for (let i = 0; i < t; i++)s.push(e(i)); return s }(this.$col, (t => ({ height: 0, left: this.$getLeft(t), top: 0, index: t }))); return t.getMinHeightItem = () => { let e = t[0]; return t.forEach((t => { t.height < e.height && (e = t) })), e }, t.getMaxHeightItem = () => { let e = t[0]; return t.forEach((t => { t.height > e.height && (e = t) })), e }, t } $renderEvents = ["$onMutation", "$onWidthChange", "$onChildrenResize", "$onAttrsChange"]; $onRender() { this.$setClass((() => ["r-falls"])); const t = this.$createList(); Array.from(this.children).forEach((e => { e.classList.add("r-falls-item"), e.style.width = this.$itemWidth; let s = t.getMinHeightItem(); s.height && (s.height = s.height + this.$roGap), e.style.left = s.left, e.style.top = s.height + "px", s.height = s.height + e.offsetHeight })), this.style.height = t.getMaxHeightItem().height + "px" } } customElements.define("r-falls", n); class o extends s { static observedAttributes = this.$initProps({ direction: { type: String, default: "row" }, inline: Boolean, reverse: Boolean, wrap: Boolean, justify: { type: String, default: "" }, align: { type: String, default: "" }, "align-self": { type: String, default: "" }, auto: { type: [String, Boolean], default: "" }, fill: { type: [String, Boolean], default: "" }, gap: { type: [Number, String], default: "" }, "row-gap": [Number, String], "column-gap": [Number, String] }); $renderEvents = ["$onConnected", "$onAttrsChange"]; $onRender() { this.$setClass((t => ["r-flex", t.inline && "r-inline-flex", t.direction && `r-flex-direction-${t.direction}`, t.reverse && `r-flex-direction-${t.direction}-reverse`, t.wrap && "r-flex-wrap", t.justify && `r-flex-justify-${t.justify}`, t.auto && `r-flex-justify-auto-${t.auto}`, t.align && `r-flex-align-${t.align}`, t["align-self"] && `r-flex-align-self-${t["align-self"]}`, t.fill && `r-flex-fill-${t.fill}`])), this.$setStyle((t => ({ "grid-gap": t.gap + "px", "row-gap": (t["row-gap"] || t.gap) + "px", "column-gap": (t["column-gap"] || t.gap) + "px" }))) } } customElements.define("r-flex", o); class l extends s { $elementName = "RScroll"; $scrollEl; constructor(...t) { super(...t), this.attachShadow({ mode: "open" }), this.$scrollEl = document.createElement("div"), this.$scrollEl.className = "r-scroll-element", this.$scrollEl.setAttribute("part", "r-scroll-element  sdt"); const e = document.createElement("div"); e.className = "r-scroll-content", e.setAttribute("part", "r-scroll-content  sdt"); const s = document.createElement("slot"); s.setAttribute("name", "top"), s.className = "top"; const i = document.createElement("slot"); i.className = "content"; const r = document.createElement("slot"); r.setAttribute("name", "bottom"), r.className = "bottom", this.shadowRoot.appendChild(this.$scrollEl), e.appendChild(i), this.$scrollEl.appendChild(s), this.$scrollEl.appendChild(e), this.$scrollEl.appendChild(r), this.$scrollEl.addEventListener("scroll", this.$onScroll.bind(this)) } $onScroll(t) { const e = this.$scrollEl; t.scrollTop = e.scrollTop, t.moveY = e.$prveScrollTop - e.scrollTop, t.moveY < 0 && this.dispatchEvent(this.$createCustomEvent("scrollUp", t)), this.onscroll && this.onscroll(t), this.dispatchEvent(this.$createCustomEvent("scroll", t)), t.moveY > 0 && this.dispatchEvent(this.$createCustomEvent("scrollDown", t)), e.$prveScrollTop = e.scrollTop } $onConnected() { this.$scrollEl.$prveScrollTop = this.$scrollEl.scrollTop, this.classList.add("r-scroll") } $onDisconnected() { this.$scrollEl.removeEventListener("scroll", this.$onScroll.bind(this)) } } customElements.define("r-scroll", l); class a extends s { static observedAttributes = this.$initProps({ top: String, left: String, right: String, bottom: String, position: { type: String, default: "right" }, visible: { type: Boolean, default: !0 }, "visible-distance": { type: Number, default: 100 }, "visible-reversal": Boolean }); $visible = !0; $cacheMoveY = 0; $scrollParent; $renderEvents = ["$onConnected", "$onAttrsChange"]; $onRender() { this.$bindStyle(), this.$bindClass() } $bindClass() { this.$setClass((t => ["r-scroll-memory-bubble", "r-scroll-memory-bubble-" + t.position, this.$visible ? "r-scroll-memory-bubble-visible" : "r-scroll-memory-bubble-hide", this.$visible ? `r-scroll-memory-bubble-visible-${t.position}` : `r-scroll-memory-bubble-hide-${t.position}`])) } $bindStyle() { this.$setStyle((t => ({ top: t.top, right: t.right, bottom: t.bottom, left: t.left }))) } $onConnected() { this.$visible = this.$attrs.visible, this.$scrollParent = this.$getParentByType("RScroll"), this.$scrollParent.addEventListener("scrollUp", this.$setVisibleFalse.bind(this)), this.$scrollParent.addEventListener("scrollDown", this.$setVisibleTrue.bind(this)) } $onDisconnected() { this.$scrollParent.removeEventListener("scrollUp", this.$setVisibleFalse.bind(this)), this.$scrollParent.removeEventListener("scrollDown", this.$setVisibleTrue.bind(this)) } $setVisibleTrue(t) { if (console.log("----scrollUp scrollDown---"), !0 === this.$visible) return this.$cacheMoveY = 0; this.$cacheMoveY = this.$cacheMoveY + Math.abs(t.moveY), this.$cacheMoveY >= this.$attrs["visible-distance"] && (this.$cacheMoveY = 0, this.$visible = !0, this.$bindClass()) } $setVisibleFalse(t) { if (console.log("----scrollUp scrollDown---"), !1 === this.$visible) return this.$cacheMoveY = 0; this.$cacheMoveY = this.$cacheMoveY + Math.abs(t.moveY), this.$cacheMoveY >= this.$attrs["visible-distance"] && (this.$cacheMoveY = 0, this.$visible = !1, this.$bindClass()) } } return customElements.define("r-scroll-memory-bable", a), t.RAbsolute = r, t.RFalls = n, t.RFlex = o, t.RGrid = i, t.RScroll = l, t.RScrollMemoryBubble = a, t.RainbowElement = s, t }({});
//# sourceMappingURL=index.main.js.map
